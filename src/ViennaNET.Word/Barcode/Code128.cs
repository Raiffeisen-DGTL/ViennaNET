using System.Collections;
using System.Drawing;
using System.Text.RegularExpressions;

namespace ViennaNET.Word.Barcode
{
  /// <summary>
  /// Представляет реализацию стандарта штрихкода Code 128.
  /// </summary>
  /// <remarks>
  /// Данная реализация перенесена из репозиторий icdb_framework,
  /// и не претерпела изменений, кроме добавления документации.
  /// Это значит, что она попрежнему содержит ошибку, 
  /// из-за которой не учитывается кодовая таблица А при кодировании.
  /// А так же формирует штрих код, без вывода под символом, кодируемой информации.
  /// </remarks>
  internal class Code128
  {
    private const int CODE128_VALUE_CODE_B = 100;
    private const int CODE128_VALUE_CODE_C = 99;
    private const int CODE128_VALUE_START_CODE_B = 104;
    private const int CODE128_VALUE_START_CODE_C = 105;
    private const int CODE128_VALUE_STOP = 106;
    private const int MAX_IMAGE_HEIGHT = 200;
    private const int MIN_IMAGE_HEIGHT = 20;
    private const int QUIET_ZONE_WIDTH = 10;

    /// <summary>
    /// Массив шаблонов (знаков) символа, представляющих структуру символа.
    /// </summary>
    /// <remarks>
    /// Каждый знак символа для данных состоит из шести элементов 
    /// (трех штрихов и трех пробелов, расположенных поочередно в направлении слева направо, начиная со штриха)
    /// Каждая строка массива это значение знака символа, каждый столбец это ширина эелемента в модулях.
    /// Первый столбец - ширина штриха, второй столбец - ширина пробела и т. д.
    /// Строки с 103 по 104 - это знак Start.
    /// Строка с индексом 106 - это знак Stop-символа и состоит из 7 элементов (четырёх штрихов и трех пробелов).
    /// Каждый пробел или штрих может содержать от 1 до 4 модулей (максимальная ширина) элемента.
    /// Сумма модулей в штрихах в любом знаке символа всегда должна быть четной (четный паритет), 
    /// поэтому сумма модулей в пробелах всегда должна быть нечетной.
    /// Суммарная длина всех штрихов и всех пробелов 11 модулей, для знака сивола Stop длина 13 модулей.
    /// </remarks>
    private readonly int[,] _patterns =
    {
      { 2, 1, 2, 2, 2, 2, 0, 0 }, /*  000  */ 
      { 2, 2, 2, 1, 2, 2, 0, 0 }, /*  001  */ 
      { 2, 2, 2, 2, 2, 1, 0, 0 }, /*  002  */
      { 1, 2, 1, 2, 2, 3, 0, 0 }, /*  003  */ 
      { 1, 2, 1, 3, 2, 2, 0, 0 }, /*  004  */ 
      { 1, 3, 1, 2, 2, 2, 0, 0 }, /*  005  */
      { 1, 2, 2, 2, 1, 3, 0, 0 }, /*  006  */ 
      { 1, 2, 2, 3, 1, 2, 0, 0 }, /*  007  */ 
      { 1, 3, 2, 2, 1, 2, 0, 0 }, /*  008  */
      { 2, 2, 1, 2, 1, 3, 0, 0 }, /*  009  */ 
      { 2, 2, 1, 3, 1, 2, 0, 0 }, /*  010  */ 
      { 2, 3, 1, 2, 1, 2, 0, 0 }, /*  011  */
      { 1, 1, 2, 2, 3, 2, 0, 0 }, /*  012  */ 
      { 1, 2, 2, 1, 3, 2, 0, 0 }, /*  013  */ 
      { 1, 2, 2, 2, 3, 1, 0, 0 }, /*  014  */
      { 1, 1, 3, 2, 2, 2, 0, 0 }, /*  015  */ 
      { 1, 2, 3, 1, 2, 2, 0, 0 }, /*  016  */ 
      { 1, 2, 3, 2, 2, 1, 0, 0 }, /*  017  */
      { 2, 2, 3, 2, 1, 1, 0, 0 }, /*  018  */ 
      { 2, 2, 1, 1, 3, 2, 0, 0 }, /*  019  */ 
      { 2, 2, 1, 2, 3, 1, 0, 0 }, /*  020  */
      { 2, 1, 3, 2, 1, 2, 0, 0 }, /*  021  */ 
      { 2, 2, 3, 1, 1, 2, 0, 0 }, /*  022  */ 
      { 3, 1, 2, 1, 3, 1, 0, 0 }, /*  023  */
      { 3, 1, 1, 2, 2, 2, 0, 0 }, /*  024  */ 
      { 3, 2, 1, 1, 2, 2, 0, 0 }, /*  025  */ 
      { 3, 2, 1, 2, 2, 1, 0, 0 }, /*  026  */
      { 3, 1, 2, 2, 1, 2, 0, 0 }, /*  027  */ 
      { 3, 2, 2, 1, 1, 2, 0, 0 }, /*  028  */ 
      { 3, 2, 2, 2, 1, 1, 0, 0 }, /*  029  */
      { 2, 1, 2, 1, 2, 3, 0, 0 }, /*  030  */ 
      { 2, 1, 2, 3, 2, 1, 0, 0 }, /*  031  */ 
      { 2, 3, 2, 1, 2, 1, 0, 0 }, /*  032  */
      { 1, 1, 1, 3, 2, 3, 0, 0 }, /*  033  */ 
      { 1, 3, 1, 1, 2, 3, 0, 0 }, /*  034  */ 
      { 1, 3, 1, 3, 2, 1, 0, 0 }, /*  035  */
      { 1, 1, 2, 3, 1, 3, 0, 0 }, /*  036  */ 
      { 1, 3, 2, 1, 1, 3, 0, 0 }, /*  037  */ 
      { 1, 3, 2, 3, 1, 1, 0, 0 }, /*  038  */
      { 2, 1, 1, 3, 1, 3, 0, 0 }, /*  039  */ 
      { 2, 3, 1, 1, 1, 3, 0, 0 }, /*  040  */ 
      { 2, 3, 1, 3, 1, 1, 0, 0 }, /*  041  */
      { 1, 1, 2, 1, 3, 3, 0, 0 }, /*  042  */ 
      { 1, 1, 2, 3, 3, 1, 0, 0 }, /*  043  */ 
      { 1, 3, 2, 1, 3, 1, 0, 0 }, /*  044  */
      { 1, 1, 3, 1, 2, 3, 0, 0 }, /*  045  */ 
      { 1, 1, 3, 3, 2, 1, 0, 0 }, /*  046  */ 
      { 1, 3, 3, 1, 2, 1, 0, 0 }, /*  047  */
      { 3, 1, 3, 1, 2, 1, 0, 0 }, /*  048  */ 
      { 2, 1, 1, 3, 3, 1, 0, 0 }, /*  049  */ 
      { 2, 3, 1, 1, 3, 1, 0, 0 }, /*  050  */
      { 2, 1, 3, 1, 1, 3, 0, 0 }, /*  051  */ 
      { 2, 1, 3, 3, 1, 1, 0, 0 }, /*  052  */ 
      { 2, 1, 3, 1, 3, 1, 0, 0 }, /*  053  */
      { 3, 1, 1, 1, 2, 3, 0, 0 }, /*  054  */ 
      { 3, 1, 1, 3, 2, 1, 0, 0 }, /*  055  */ 
      { 3, 3, 1, 1, 2, 1, 0, 0 }, /*  056  */
      { 3, 1, 2, 1, 1, 3, 0, 0 }, /*  057  */ 
      { 3, 1, 2, 3, 1, 1, 0, 0 }, /*  058  */ 
      { 3, 3, 2, 1, 1, 1, 0, 0 }, /*  059  */
      { 3, 1, 4, 1, 1, 1, 0, 0 }, /*  060  */ 
      { 2, 2, 1, 4, 1, 1, 0, 0 }, /*  061  */ 
      { 4, 3, 1, 1, 1, 1, 0, 0 }, /*  062  */
      { 1, 1, 1, 2, 2, 4, 0, 0 }, /*  063  */ 
      { 1, 1, 1, 4, 2, 2, 0, 0 }, /*  064  */ 
      { 1, 2, 1, 1, 2, 4, 0, 0 }, /*  065  */
      { 1, 2, 1, 4, 2, 1, 0, 0 }, /*  066  */ 
      { 1, 4, 1, 1, 2, 2, 0, 0 }, /*  067  */ 
      { 1, 4, 1, 2, 2, 1, 0, 0 }, /*  068  */
      { 1, 1, 2, 2, 1, 4, 0, 0 }, /*  069  */ 
      { 1, 1, 2, 4, 1, 2, 0, 0 }, /*  070  */ 
      { 1, 2, 2, 1, 1, 4, 0, 0 }, /*  071  */
      { 1, 2, 2, 4, 1, 1, 0, 0 }, /*  072  */ 
      { 1, 4, 2, 1, 1, 2, 0, 0 }, /*  073  */ 
      { 1, 4, 2, 2, 1, 1, 0, 0 }, /*  074  */
      { 2, 4, 1, 2, 1, 1, 0, 0 }, /*  075  */ 
      { 2, 2, 1, 1, 1, 4, 0, 0 }, /*  076  */ 
      { 4, 1, 3, 1, 1, 1, 0, 0 }, /*  077  */
      { 2, 4, 1, 1, 1, 2, 0, 0 }, /*  078  */ 
      { 1, 3, 4, 1, 1, 1, 0, 0 }, /*  079  */ 
      { 1, 1, 1, 2, 4, 2, 0, 0 }, /*  080  */
      { 1, 2, 1, 1, 4, 2, 0, 0 }, /*  081  */ 
      { 1, 2, 1, 2, 4, 1, 0, 0 }, /*  082  */ 
      { 1, 1, 4, 2, 1, 2, 0, 0 }, /*  083  */
      { 1, 2, 4, 1, 1, 2, 0, 0 }, /*  084  */ 
      { 1, 2, 4, 2, 1, 1, 0, 0 }, /*  085  */ 
      { 4, 1, 1, 2, 1, 2, 0, 0 }, /*  086  */
      { 4, 2, 1, 1, 1, 2, 0, 0 }, /*  087  */ 
      { 4, 2, 1, 2, 1, 1, 0, 0 }, /*  088  */ 
      { 2, 1, 2, 1, 4, 1, 0, 0 }, /*  089  */
      { 2, 1, 4, 1, 2, 1, 0, 0 }, /*  090  */ 
      { 4, 1, 2, 1, 2, 1, 0, 0 }, /*  091  */ 
      { 1, 1, 1, 1, 4, 3, 0, 0 }, /*  092  */
      { 1, 1, 1, 3, 4, 1, 0, 0 }, /*  093  */ 
      { 1, 3, 1, 1, 4, 1, 0, 0 }, /*  094  */ 
      { 1, 1, 4, 1, 1, 3, 0, 0 }, /*  095  */
      { 1, 1, 4, 3, 1, 1, 0, 0 }, /*  096  */ 
      { 4, 1, 1, 1, 1, 3, 0, 0 }, /*  097  */ 
      { 4, 1, 1, 3, 1, 1, 0, 0 }, /*  098  */
      { 1, 1, 3, 1, 4, 1, 0, 0 }, /*  099  */ 
      { 1, 1, 4, 1, 3, 1, 0, 0 }, /*  100  */ 
      { 3, 1, 1, 1, 4, 1, 0, 0 }, /*  101  */
      { 4, 1, 1, 1, 3, 1, 0, 0 }, /*  102  */ 
      { 2, 1, 1, 4, 1, 2, 0, 0 }, /*  103 - START */ 
      { 2, 1, 1, 2, 1, 4, 0, 0 }, /*  104 - START */
      { 2, 1, 1, 2, 3, 2, 0, 0 }, /*  105 - START */ 
      { 2, 3, 3, 1, 1, 1, 2, 0 }  /*  106 - STOP  */
    };

    /// <summary>
    ///   Сформировать изображение бар-кода.
    /// </summary>
    /// <param name="text">Строка для шифрования.</param>
    /// <param name="force_code_b">Признак, определяющий набор таблиц шифрования.</param>
    /// <param name="bar_weight">Толщина модуля.</param>
    /// <param name="height">Высота изображения бар-кода.</param>
    /// <param name="add_quiet_zone">true, если необходимо добавить отступы слева и справа, в противном случае - false.</param>
    /// <returns>Возвращает изображение бар-кода.</returns>
    public Image Barcode(string text, bool force_code_b, BarWeight bar_weight, int height, bool add_quiet_zone)
    {
      int cursor;
      int width;
      int[] values;
      var modules_count = new ModulesCount();

      // Шифруем строку.
      values = Encode(text, force_code_b);
      if (values.Length == 0)
      {
        return null;
      }

      // Ширина изображения бар-кода
      // Ширина знака равна 11 модулям. Остановочный (стоп) знак
      // состоит из тринадцати модулей.
      width = ((values.Length - 1) * 11 + 13) * (int)bar_weight;
      // Отступы, если это необходимо.
      width += (add_quiet_zone ? QUIET_ZONE_WIDTH * (int)bar_weight * 2 : 0);

      // Высота изображения бар-кода.
      if (height < MIN_IMAGE_HEIGHT || height > MAX_IMAGE_HEIGHT)
      {
        height = MIN_IMAGE_HEIGHT;
      }

      // Поверхность для отрисовки...
      Image image = new Bitmap(width, height);
      using (var graphics = Graphics.FromImage(image))
      {
        // "Заливаем" поверхность белым цветом, чтобы впоследствие
        // отрисовывать только штрихи.
        graphics.FillRectangle(Brushes.White, 0, 0, width, height);
        // Текущее значение X-координаты.
        cursor = add_quiet_zone ? QUIET_ZONE_WIDTH * (int)bar_weight : 0;

        // Отрисовываем символы в соответствие с их значениями...
        for (var i = 0; i < values.Length; i++)
        {
          // Символ отрисовываем парами: штрих - пробел в соответствие с его структурой...
          for (var j = 0; j <= _patterns.GetUpperBound(1); j += 2)
          {
            // Количество модулей в штрихе.
            modules_count.Bar = _patterns[values[i], j] * (int)bar_weight;
            // Количество модулей в пробеле.
            modules_count.Space = _patterns[values[i], j + 1] * (int)bar_weight;
            // Если количество модулей в штрихе отлично от нуля...
            if (modules_count.Bar > 0)
            {
              // Отрисовываем штрих пары.
              graphics.FillRectangle(Brushes.Black, cursor, 0, modules_count.Bar, height);
            }
            // Смещаем X-координату к началу следующей пары символа.
            cursor += modules_count.Total;
          }
        }
      }

      return image;
    }

    /// <summary>
    /// Рассчитывает значение контрольного знака символа Code 128.
    /// </summary>
    /// <param name="tokens">Массив знаков символа.</param>
    /// <returns>Возвращает значение контрольного знака символа.</returns>
    /// <remarks>
    /// Каждой позиции знака символа присваивают весовой коэффициент.
    /// Первый знак, токен с индексом 0 имеет вес равный 1.
    /// Знаки данных начиная с индекса 1 до конца массива имеют веса равные их индексу в массиве.
    /// В массиве знаков, на данном этапе, не должно быть знака STOP и контрольного знака.
    /// </remarks>
    private int CalculateSymbolSign(int[] tokens)
    {
      var result = tokens[0] * 1;

      for (var i = 1; i < tokens.Length; i++)
      {
        result += tokens[i] * i;
      }
      return result % 103;
    }

    /// <summary>
    /// Выполняет кодирование входящей строки в символы штрих-кода Code 128.
    /// </summary>
    /// <param name="value">Кодируемое сообщение.</param>
    /// <param name="forceCodeB">-?</param>
    /// <returns>Последовательность значений знаков Code 128.</returns>
    private int[] Encode(string value, bool forceCodeB)
    {
      var aValues = new ArrayList();
      var iPos = 0;

      MatchCollection oMatches;
      var oRegex = new Regex("[^\\x20-\\x7E]+", RegexOptions.Singleline);

      if (value.Length > 0 && oRegex.Matches(value).Count == 0)
      {
        // Если допускается использование таблиц CodeB и CodeC...
        if (!forceCodeB)
        {
          // Извлекаем все группы чисел из строки,  которые содержат
          // четное количество цифр и длина каждой группы - не менее
          // 4-х цифр.
          oRegex = new Regex("(\\d\\d){2,}", RegexOptions.Singleline);
          oMatches = oRegex.Matches(value);
          for (var i = 0; i < oMatches.Count; i++)
          {
            // Если группа стоит в начале строки (допускается 4-е циф-
            // ры),  если длина группы не менее 6-и цифр,  если группа
            // стоит в конце строки (допускается 4-е цифры)...
            if (oMatches[i].Index == 0 || oMatches[i].Length >= 6 || oMatches[i].Index + oMatches[i].Length == value.Length)
            {
              // Добавляем последовательность CodeB (предшествующая).
              aValues.AddRange(GetValuesCodeB(value.Substring(iPos, oMatches[i].Index - iPos)));

              // Добавляем последовательность CodeC (текущая).
              aValues.AddRange(GetValuesCodeC(oMatches[i].Value));

              // Смещаем текущую позицию в строке.
              iPos = oMatches[i].Index + oMatches[i].Length;
            }
          }
        }
        // Если обработаны не все последовательности...
        if (iPos < value.Length)
        {
          // Добавляем последовательность CodeB.
          aValues.AddRange(GetValuesCodeB(value.Substring(iPos, value.Length - iPos)));
        }

        // Заменяем самый первый символ (символ признака таблицы) на стартовый.
        switch ((int)aValues[0])
        {
          case CODE128_VALUE_CODE_B:
            aValues[0] = CODE128_VALUE_START_CODE_B;
            break;
          case CODE128_VALUE_CODE_C:
            aValues[0] = CODE128_VALUE_START_CODE_C;
            break;
        }

        aValues.Add(CalculateSymbolSign(aValues.ToArray(typeof(int)) as int[]));
        aValues.Add(CODE128_VALUE_STOP);
      }
      // Возвращаем последовательность значений.
      return aValues.ToArray(typeof(int)) as int[];
    }

    /// <summary>
    /// Кодирует входную строку по кодовой таблице Code B.
    /// </summary>
    /// <param name="sData">Входная строка.</param>
    /// <returns>Значение знака в кодовой таблице Code B.</returns>
    private int[] GetValuesCodeB(string sData)
    {
      if (sData.Length > 0)
      {
        var aValues = new int[sData.Length + 1];
        aValues[0] = CODE128_VALUE_CODE_B;
        for (var i = 0; i < sData.Length; i++)
        {
          aValues[i + 1] = sData[i] - 32;
        }
        return aValues;
      }
      else
      {
        return new int[0];
      }
    }

    /// <summary>
    /// Кодирует входную строку по кодовой таблице Code C.
    /// </summary>
    /// <param name="sData">Входная строка.</param>
    /// <returns>Значение знака в кодовой таблице Code C.</returns>
    private int[] GetValuesCodeC(string sData)
    {
      if (sData.Length > 0)
      {
        var aValues = new int[sData.Length / 2 + 1];
        aValues[0] = CODE128_VALUE_CODE_C;

        for (var i = 0; i < sData.Length; i += 2)
        {
          aValues[i / 2 + 1] = int.Parse(sData.Substring(i, 2));
        }

        return aValues;
      }

      return new int[0];
    }
  }
}